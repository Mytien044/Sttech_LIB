<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>eBook - Hệ thống quản lý thư viện sách trực tuyến</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    
    <link rel="stylesheet" href="/demoEbook/IndexEbook/3rds/3d-flipbook/css/main.css">
</head>
<body>
        <section id="gioi-thieu" class="hero-section">
            <div id="threejs-container"></div>
            <div class="container hero-content">
                <h1 class="hero-title">STTECH - Sáng tạo vì Tương lai số</h1>
                <p class="hero-subtitle">“Công nghệ không chỉ thay đổi thế giới, mà còn mở ra con đường dẫn tới tri thức và tương lai.”</p>
                <div class="hero-buttons">
                    <a href="#phan-he" class="btn btn-gradient">Khám phá giải pháp</a>
                    <a href="#nguoi-dung" class="btn btn-outline">Về chúng tôi</a>
                </div>
            </div>
            <div class="hero-overlay"></div>
        </section>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
       import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// 1. Setup cơ bản
const container = document.getElementById('threejs-container');
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });

renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
container.appendChild(renderer.domElement);

// Điều chỉnh camera ban đầu
camera.position.set(0, 5, 10); // Đặt camera cao hơn và lùi xa hơn
camera.lookAt(0, 0, 0);       // Nhìn vào trung tâm cảnh

// Màu sắc chủ đạo (Xanh lá cây và Neon)
const gridColor = new THREE.Color(0x0a2a0a); // Xanh lá cây đậm
const nodeColor = new THREE.Color(0x00ff00); // Xanh lá neon
const connectionColor = new THREE.Color(0x00cc00); // Xanh lá sáng hơn
const highlightColor = new THREE.Color(0xffff00); // Vàng neon cho các điểm di chuyển

// 2. Tạo đối tượng 3D (Dynamic Tech Grid)

// 2.1. Lưới nền (Grid Helper)
const size = 20;
const divisions = 20;
const gridHelper = new THREE.GridHelper(size, divisions, gridColor, gridColor);
gridHelper.material.opacity = 0.3; // Làm mờ lưới
gridHelper.material.transparent = true;
scene.add(gridHelper);

// 2.2. Các điểm (Nodes) trên lưới
const nodeCount = 150;
const nodePositions = new Float32Array(nodeCount * 3);
const nodes = []; // Lưu trữ các vector vị trí cho các node
const nodeVelocities = []; // Lưu trữ vận tốc di chuyển của từng node

for (let i = 0; i < nodeCount; i++) {
    // Vị trí ngẫu nhiên trên mặt phẳng XZ (y = 0)
    const x = (Math.random() - 0.5) * size;
    const z = (Math.random() - 0.5) * size;
    const y = (Math.random() - 0.5) * 1; // Hơi nhấp nhô nhẹ quanh trục Y
    
    nodePositions[i * 3] = x;
    nodePositions[i * 3 + 1] = y;
    nodePositions[i * 3 + 2] = z;
    
    nodes.push(new THREE.Vector3(x, y, z));
    nodeVelocities.push(new THREE.Vector3(
        (Math.random() - 0.5) * 0.005,
        (Math.random() - 0.5) * 0.005,
        (Math.random() - 0.5) * 0.005
    ));
}

const nodeGeometry = new THREE.BufferGeometry();
nodeGeometry.setAttribute('position', new THREE.BufferAttribute(nodePositions, 3));

const nodeMaterial = new THREE.PointsMaterial({
    color: nodeColor,
    size: 0.1,
    blending: THREE.AdditiveBlending,
    transparent: true,
    opacity: 0.9
});

const nodeSystem = new THREE.Points(nodeGeometry, nodeMaterial);
scene.add(nodeSystem);

// 2.3. Các đường nối (Connections) giữa các node
const lineGeometry = new THREE.BufferGeometry();
const linePositions = [];
const maxConnectDistance = 3; // Khoảng cách tối đa để tạo đường nối

const tempLines = new THREE.Group(); // Sử dụng Group để dễ dàng quản lý các đường
scene.add(tempLines);

// 3. Thêm tương tác chuột
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enableZoom = false;
controls.enablePan = false;
controls.autoRotate = true;
controls.autoRotateSpeed = 0.2; // Tốc độ xoay chậm và mượt mà

// 4. Vòng lặp Animation
let time = 0;
function animate() {
    requestAnimationFrame(animate);

    // Cập nhật vị trí các node và đường nối
    tempLines.children = []; // Xóa các đường cũ mỗi khung hình
    const currentLinePositions = [];

    for (let i = 0; i < nodeCount; i++) {
        const node = nodes[i];
        const velocity = nodeVelocities[i];

        // Di chuyển node
        node.add(velocity);

        // Giới hạn node trong khu vực lưới
        if (node.x > size / 2 || node.x < -size / 2) velocity.x *= -1;
        if (node.y > 0.5 || node.y < -0.5) velocity.y *= -1; // Giới hạn nhấp nhô
        if (node.z > size / 2 || node.z < -size / 2) velocity.z *= -1;

        // Cập nhật vị trí trong BufferAttribute
        nodePositions[i * 3] = node.x;
        nodePositions[i * 3 + 1] = node.y;
        nodePositions[i * 3 + 2] = node.z;

        // Tìm kiếm các node gần để tạo đường nối
        for (let j = i + 1; j < nodeCount; j++) {
            const otherNode = nodes[j];
            const distance = node.distanceTo(otherNode);

            if (distance < maxConnectDistance) {
                // Tạo một đường giữa hai node
                const points = [];
                points.push(node.clone());
                points.push(otherNode.clone());
                const lineGeo = new THREE.BufferGeometry().setFromPoints(points);

                // Độ mờ của đường phụ thuộc vào khoảng cách
                const opacity = (1 - (distance / maxConnectDistance)) * 0.3; 

                // Hiệu ứng "tia sáng" chạy trên đường
                const t = (time * 2 + i + j) % 2; // Thời gian cục bộ cho hiệu ứng chạy
                let currentLineColor = connectionColor;
                if (t < 0.1 || t > 1.9) { // Tại đầu hoặc cuối đường
                    currentLineColor = highlightColor;
                } else if (t > 0.4 && t < 0.6) { // Khoảng giữa đường
                     currentLineColor = highlightColor;
                }

                const lineMat = new THREE.LineBasicMaterial({
                    color: currentLineColor,
                    transparent: true,
                    opacity: opacity,
                    blending: THREE.AdditiveBlending
                });
                const line = new THREE.Line(lineGeo, lineMat);
                tempLines.add(line);
            }
        }
    }
    
    // Cần cập nhật geometry của các điểm
    nodeGeometry.attributes.position.needsUpdate = true;

    time += 0.01;

    controls.update();
    renderer.render(scene, camera);
}

animate();

// 5. Xử lý responsive
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
    </script>
</body>
</html>